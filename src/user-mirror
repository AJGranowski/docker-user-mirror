#!/bin/sh
set -eC;

# Parse options
while [ $# -gt 0 ]; do
    case $1 in
        --docker)
            COMPOSE_ENGINE='docker compose';
            CONTAINER_ENGINE='docker';
            ;;
        --docker-compose)
            COMPOSE_ENGINE='docker-compose';
            CONTAINER_ENGINE='docker';
            ;;
        --podman)
            COMPOSE_ENGINE='podman compose';
            CONTAINER_ENGINE='podman';
            ;;
        --podman-compose)
            COMPOSE_ENGINE='podman-compose';
            CONTAINER_ENGINE='podman';
            ;;
        --)
            shift;
            break;
            ;;
        -*)
            printf 'Unknown option %s\n' $1 >&2;
            exit 1;
            ;;
        *)
            break;
            ;;
    esac
    shift;
done

if [ -z "$COMPOSE_ENGINE" ] || [ -z "$CONTAINER_ENGINE" ]; then
    case $1 in
        docker-compose)
            COMPOSE_ENGINE='docker-compose';
            CONTAINER_ENGINE='docker';
            ;;
        podman)
            COMPOSE_ENGINE='podman compose';
            CONTAINER_ENGINE='podman';
            ;;
        podman-compose)
            COMPOSE_ENGINE='podman-compose';
            CONTAINER_ENGINE='podman';
            ;;
        *)
            COMPOSE_ENGINE='docker compose';
            CONTAINER_ENGINE='docker';
    esac
fi

COMPOSE_FILES="";
for arg do
    case $arg in
        -f|--file)
            COMPOSE_FILES="--file $1";
            ;;
    esac
done

if [ "$CONTAINER_ENGINE" = "podman" ] || docker info -f '{{println .SecurityOptions}}' | grep 'rootless' 1>/dev/null; then
    first_iteration=true;
    search_for_insert=true;
    for arg do
        if [ "$first_iteration" = 'true' ]; then
            unset first_iteration;
            shift $#;
        fi

        if [ "$search_for_insert" = 'true' ]; then
            case $arg in
                create|exec|run)
                    set -- "$@" "$arg" '--env' 'GID=0' '--env' 'GROUP=root' '--env' 'UID=0' '--env' 'USER=root';
                    unset search_for_insert;
                    ;;
                *)
                    set -- "$@" "$arg";
                    ;;
            esac
        else
            set -- "$@" "$arg";
        fi
    done
else

    # Parse docker-compose.yml by attempting to create and parse a container (but not starting it).
    if $COMPOSE_ENGINE --progress quiet $COMPOSE_FILES create >/dev/null; then
        TEMP_CONTAINER_ID="$($COMPOSE_ENGINE --progress quiet $COMPOSE_FILES ps -a --status created --format '{{.ID}}')";

        # Create a list of paths to chown within the container.
        CHOWN_LIST="$($CONTAINER_ENGINE inspect --format '{{range .Mounts}}{{if (ne .Mode "")}}"{{print .Destination}}" {{end}}{{end}}' "$TEMP_CONTAINER_ID")";

        # Create host bind paths that where create_host_path=true.
        while read create_path; do
            if [ -z "$create_path" ]; then
                break;
            fi

            mkdir -p "$create_path" >/dev/null 2>&1 || true;
        done <<EOF
$($CONTAINER_ENGINE inspect --format '{{range .Mounts}}{{if and (eq .Type "bind") (ne .Mode "")}}{{println .Source}}{{end}}{{end}}' "$TEMP_CONTAINER_ID")
EOF
        # Create mounts nested within bind mounts on the host.
        while read edge_source; do
            if [ -z "$edge_source" ]; then
                break;
            fi

            read edge_destination;

            while read node_source; do
                if [ -z "$node_source" ]; then
                    break;
                fi

                read node_destination;

                resolved_node_destination="$(echo "$node_destination" | sed -e "s|^${edge_destination}/|${edge_source}/|g")";
                if [ "$resolved_node_destination" = "$node_destination" ]; then
                    # Skip if no resolution was made
                    continue;
                fi

                if [ -f "$node_source" ]; then
                    mkdir -p "$(dirname "$resolved_node_destination")" >/dev/null 2>&1 || true;
                    touch "$resolved_node_destination";
                else
                    mkdir -p "$resolved_node_destination" >/dev/null 2>&1 || true;
                fi
            done <<EOF
$($CONTAINER_ENGINE inspect --format '{{range .Mounts}}{{println .Source}}{{println .Destination}}{{end}}' "$TEMP_CONTAINER_ID")
EOF

        done <<EOF
$($CONTAINER_ENGINE inspect --format '{{range .Mounts}}{{if eq .Type "bind"}}{{println .Source}}{{println .Destination}}{{end}}{{end}}' "$TEMP_CONTAINER_ID")
EOF

        $CONTAINER_ENGINE container rm "$TEMP_CONTAINER_ID" >/dev/null 2>&1;
    fi

    first_iteration=true;
    search_for_insert=true;
    for arg do
        if [ "$first_iteration" = 'true' ]; then
            unset first_iteration;
            shift $#;
        fi

        if [ "$search_for_insert" = 'true' ]; then
            case $arg in
                create|exec|run)
                    set -- "$@" "$arg" '--env' "GID=$(id -g)" '--env' "GROUP=$(id -gn)" '--env' "UID=$(id -u)" '--env' "USER=$(id -un)";
                    if [ -n "$CHOWN_LIST" ]; then
                        set -- "$@" '--env' "CHOWN=$CHOWN_LIST";
                    fi
                    unset search_for_insert;
                    ;;
                *)
                    set -- "$@" "$arg";
                    ;;
            esac
        else
            set -- "$@" "$arg";
        fi
    done
fi

"$@";